// src/infrastructure/dependencies.ts

import { PrismaClient } from '@prisma/client'

// Existing – Draft domain wiring
import { DraftService } from '../application/draft/service/DraftService'
import { ProspectRepository } from '../infrastructure/repositories/ProspectRepository'
import { TeamNeedRepository } from '../infrastructure/repositories/TeamNeedRepository'

// Teams & Games repos (Prisma)
import { PrismaTeamRepository as TeamRepository } from '../infrastructure/repositories/PrismaTeamRepository'
import { PrismaGameRepository } from './repositories/PrismaGameRepository'

// ESPN client + Services
import { EspnScoreboardClient } from './scoreboardClient'
import { ImportNflScoresService } from '../services/importNflScores'
import { BackfillSeasonService } from '../services/backfillSeason'   // ✅ added
import { SyncTeamsService } from '../services/syncTeams'             // ✅ added
import { prisma } from '../infrastructure/prisma';

// Job logger (Prisma impl)
import { PrismaJobLogger } from './repositories/PrismaJobLogger'

// ------------------------------------------------------------------
// Repositories
// ------------------------------------------------------------------
const prospectRepository  = new ProspectRepository(prisma)
const teamNeedRepository  = new TeamNeedRepository(prisma)
const teamRepository      = new TeamRepository()
const gameRepository      = new PrismaGameRepository(prisma)

// ------------------------------------------------------------------
// Infra: ESPN client + Job logger
// ------------------------------------------------------------------
const espnClient = new EspnScoreboardClient()
const jobLogger  = new PrismaJobLogger(prisma)

// ------------------------------------------------------------------
// Services
// ------------------------------------------------------------------
const draftService = new DraftService(
  prospectRepository,
  teamNeedRepository
)

const importWeekService     = new ImportNflScoresService(espnClient, gameRepository, jobLogger)
const backfillSeasonService = new BackfillSeasonService(espnClient, gameRepository, jobLogger)
const syncTeamsService      = new SyncTeamsService(espnClient, teamRepository, jobLogger)

// ------------------------------------------------------------------
// Exports
// ------------------------------------------------------------------
export {
  prisma,

  // Repos
  prospectRepository,
  teamNeedRepository,
  teamRepository,
  gameRepository,

  // Infra
  espnClient,
  jobLogger,

  // Services
  draftService,
  importWeekService,
  backfillSeasonService,
  syncTeamsService,
}

// src/application/jobs/services/QueueJobService.ts
import { JobRepository } from '../../../domain/jobs/repositories/JobRepository';
import { Job } from '../../../domain/jobs/entities/Job';
import { JobStatus } from '../../../domain/jobs/value-objects/JobStatus';
import { JobType } from '../../../domain/jobs/value-objects/JobType';
import { CreateJobRequest } from '../dto/CreateJobRequest';

export class QueueJobService {
  constructor(private readonly jobs: JobRepository) {}
  async execute(req: CreateJobRequest): Promise<Job> {
    const job = new Job(
      null,
      req.type as JobType,
      req.payload,
      JobStatus.PENDING,
      new Date()
    );
    return await this.jobs.create(job);
  }
}

// src/application/jobs/services/RunJobService.ts
import { JobRepository } from '../../../domain/jobs/repositories/JobRepository';
import { JobLogRepository } from '../../../domain/jobs/repositories/JobLogRepository';
import { Job } from '../../../domain/jobs/entities/Job';
import { JobStatus } from '../../../domain/jobs/value-objects/JobStatus';
import { InProcessJobRunner, RunResult } from '../../../infrastructure/queue/InProcessJobRunner';
import { JobLogEmitter } from '../../../infrastructure/queue/JobLogEmitter';
import { JobLog, LogLevel } from '@/domain/jobs/entities/JobLog';

export class RunJobService {
  constructor(
    private readonly jobs: JobRepository,
    private readonly logs: JobLogRepository,
    private readonly runner: InProcessJobRunner,
    private readonly emitter: JobLogEmitter
  ) {}

  async execute(jobId: number): Promise<Job> {
    const job = await this.jobs.findById(jobId);
    if (!job) throw new Error('Job not found');

    if (![JobStatus.PENDING].includes(job.status)) {
      throw new Error(`Job not runnable from status ${job.status}`);
    }

    job.start();
    await this.jobs.update(job);

    try {
      const res: RunResult = await this.runner.run(job, {
        log: async (level: LogLevel, message: string) => {
          // ✅ New log => id must be null; jobId is the job's id
          const saved = await this.logs.append(
            new JobLog(null, job.id!, level, message, new Date())
          );

          // ✅ Emit with the DB-assigned log id (if your emitter signature supports it)
          // If your emitter is emit(jobId, level, message) without id, just omit saved.id.
          this.emitter.emit(job.id!, level, message, saved.id ?? undefined);
        },
        shouldCancel: async () => {
          const latest = await this.jobs.findById(job.id!);
          return latest?.status === JobStatus.CANCELED;
        },
      });

      // Map RunResult fields to your Job.complete(...) shape
      job.complete(res.code ?? 'OK', (res as any).result ?? (res as any).data ?? null);
      await this.jobs.update(job);
      return job;
    } catch (err: any) {
      job.fail('ERROR', { message: err?.message ?? String(err) });
      await this.jobs.update(job);
      throw err;
    }
  }
}

// src/application/jobs/services/CancelJobService.ts
import { JobRepository } from '../../../domain/jobs/repositories/JobRepository';

export class CancelJobService {
  constructor(private readonly jobs: JobRepository) {}
  async execute(jobId: number, reason = 'user-request'): Promise<void> {
    const job = await this.jobs.findById(jobId);
    if (!job) throw new Error('Job not found');
    job.cancel(reason);
    await this.jobs.update(job);
  }
}

// src/application/jobs/services/ListJobsService.ts
import { JobRepository, ListJobsFilter, Pagination, PagedResult } from '../../../domain/jobs/repositories/JobRepository';
import { Job } from '../../../domain/jobs/entities/Job';

export class ListJobsService {
  constructor(private readonly jobs: JobRepository) {}
  async execute(filter: ListJobsFilter, pg: Pagination): Promise<PagedResult<Job>> {
    return this.jobs.list(filter, pg);
  }
}

// src/application/jobs/services/GetJobDetailService.ts
import { JobRepository } from '../../../domain/jobs/repositories/JobRepository';
import { Job } from '../../../domain/jobs/entities/Job';

export class GetJobDetailService {
  constructor(private readonly jobs: JobRepository) {}
  async execute(jobId: number): Promise<Job> {
    const job = await this.jobs.findById(jobId);
    if (!job) throw new Error('Job not found');
    return job;
  }
}

// src/application/jobs/services/GetJobLogsService.ts
import { JobLogRepository } from '../../../domain/jobs/repositories/JobLogRepository';
import { JobLog } from '../../../domain/jobs/entities/JobLog';

export default class GetJobLogService {
  constructor(private readonly logs: JobLogRepository) {}
  async execute(jobId: number, sinceId?: number): Promise<JobLog[]> {
    return this.logs.listByJobId(jobId, sinceId);
    }
}

// src/application/jobs/services/ScheduleJobService.ts
import { CronScheduler } from '../../../infrastructure/schedule/CronScheduler';
import { CreateJobRequest } from '../dto/CreateJobRequest';

export class ScheduleJobService {
  constructor(private readonly scheduler: CronScheduler) {}
  add(name: string, cron: string, jobFactory: () => Promise<void>, active = true) {
    this.scheduler.register(name, cron, jobFactory, active);
  }
  remove(name: string) { this.scheduler.unregister(name); }
  list() { return this.scheduler.list(); }
}

